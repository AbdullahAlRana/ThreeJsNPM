<!DOCTYPE html>
<html lang="en">

<head>
    <title>Practice --ðŸŽ¨--</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            background-color: #ccc;
            color: #000;
        }

        a {
            color: #f00;
        }
    </style>
</head>

<body>
    <script type="module">

        import * as THREE from '/node_modules/three/src/Three.js';
        import { OrbitControls } from '/node_modules/three/examples/jsm/controls/OrbitControls.js';

        let camera, scene, renderer, controls, mesh;

        const createWorld = () => {
            const wallGroup = new THREE.Group();
            const wall = new THREE.Object3D();

            wallGroup.add(wall);
            scene.add(wallGroup);

            const wallShape = new THREE.Shape();
            wallShape.moveTo(0, 0);
            wallShape.lineTo(4.01, 0.05);
            wallShape.lineTo(4, 1.01);
            wallShape.lineTo(0, 1.05);
            wallShape.lineTo(0, 0);
            const wallGeometry = new THREE.ExtrudeBufferGeometry([wallShape], {
                steps: 1,
                depth: 0.2,
                bevelEnabled: false,
                curveSegments: 32
            });

            function createWall(initX1, inity1)
            {

            }

            const wallA = new THREE.Mesh(wallGeometry, new THREE.MeshStandardMaterial({ color: 0xff9999 }));
            wall.add(wallA);

            // const wallB = wallA.clone();
            // wallB.translateZ(-1.8);
            // wall.add(wallB);

            const ground = new THREE.Mesh(new THREE.PlaneBufferGeometry(100, 100), new THREE.MeshStandardMaterial({ color: 0xffffff }));
            ground.rotateX(-Math.PI / 2);
            ground.translateX(-0.5);
            ground.translateY(-0.5);
            wallGroup.add(ground);

            wall.translateX(-0.5);
            wall.translateZ(-0.5);

            wall.traverse(mesh => (mesh !== wall ? mesh.visible = false : null));

            mesh = [wallGroup, wall];

            camera.lookAt(wallGroup.position);

            //let step = 0;

            wall.children.forEach((mesh, index) => mesh.visible = true);

            // setInterval(() => {
            //     step = (step + 1) % (wall.children.length + 1);

            //     wall.children.forEach((mesh, index) => mesh.visible = index < step);
            // }, 1000);
        };

        const init = () => {
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000.0);
            camera.position.set(-5, 5, 7);

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x333333);

            scene.add(new THREE.HemisphereLight(0xffffcc, 0x19bbdc, 1));

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);

            document.body.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);

            createWorld();
        }

        const animate = () => {
            requestAnimationFrame(animate);

            controls.update();

            renderer.render(scene, camera);

            //mesh[0].rotateY(.01);
        }

        init();
        animate();


    </script>

</body>

</html>